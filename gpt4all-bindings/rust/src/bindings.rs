/* automatically generated by rust-bindgen 0.69.4 */

pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__mbstate_t),
        "::",
        stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__mbstate_t),
        "::",
        stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__darwin_pthread_handler_rec),
        "::",
        stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(__darwin_pthread_handler_rec),
        "::",
        stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(__darwin_pthread_handler_rec),
        "::",
        stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_attr_t),
        "::",
        stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_attr_t),
        "::",
        stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_cond_t),
        "::",
        stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_cond_t),
        "::",
        stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_condattr_t),
        "::",
        stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_condattr_t),
        "::",
        stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_mutex_t),
        "::",
        stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_mutex_t),
        "::",
        stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_mutexattr_t),
        "::",
        stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_mutexattr_t),
        "::",
        stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_once_t),
        "::",
        stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_once_t),
        "::",
        stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_rwlock_t),
        "::",
        stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_rwlock_t),
        "::",
        stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_rwlockattr_t),
        "::",
        stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_rwlockattr_t),
        "::",
        stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_t),
        "::",
        stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_t),
        "::",
        stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(_opaque_pthread_t),
        "::",
        stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
#[doc = " Opaque pointer to the underlying model."]
pub type llmodel_model = *mut ::std::os::raw::c_void;
#[doc = " llmodel_prompt_context structure for holding the prompt context.\n NOTE: The implementation takes care of all the memory handling of the raw logits pointer and the\n raw tokens pointer. Attempting to resize them or modify them in any way can lead to undefined\n behavior."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llmodel_prompt_context {
    pub logits: *mut f32,
    pub logits_size: usize,
    pub tokens: *mut i32,
    pub tokens_size: usize,
    pub n_past: i32,
    pub n_ctx: i32,
    pub n_predict: i32,
    pub top_k: i32,
    pub top_p: f32,
    pub min_p: f32,
    pub temp: f32,
    pub n_batch: i32,
    pub repeat_penalty: f32,
    pub repeat_last_n: i32,
    pub context_erase: f32,
}
#[test]
fn bindgen_test_layout_llmodel_prompt_context() {
    const UNINIT: ::std::mem::MaybeUninit<llmodel_prompt_context> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llmodel_prompt_context>(),
        80usize,
        concat!("Size of: ", stringify!(llmodel_prompt_context))
    );
    assert_eq!(
        ::std::mem::align_of::<llmodel_prompt_context>(),
        8usize,
        concat!("Alignment of ", stringify!(llmodel_prompt_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logits) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(logits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logits_size) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(logits_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tokens) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(tokens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tokens_size) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(tokens_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_past) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(n_past)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_ctx) as usize - ptr as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(n_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_predict) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(n_predict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_k) as usize - ptr as usize },
        44usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(top_k)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_p) as usize - ptr as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(top_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_p) as usize - ptr as usize },
        52usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(min_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temp) as usize - ptr as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(temp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_batch) as usize - ptr as usize },
        60usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(n_batch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repeat_penalty) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(repeat_penalty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repeat_last_n) as usize - ptr as usize },
        68usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(repeat_last_n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_erase) as usize - ptr as usize },
        72usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_prompt_context),
        "::",
        stringify!(context_erase)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llmodel_gpu_device {
    pub index: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub heapSize: usize,
    pub name: *const ::std::os::raw::c_char,
    pub vendor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_llmodel_gpu_device() {
    const UNINIT: ::std::mem::MaybeUninit<llmodel_gpu_device> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llmodel_gpu_device>(),
        32usize,
        concat!("Size of: ", stringify!(llmodel_gpu_device))
    );
    assert_eq!(
        ::std::mem::align_of::<llmodel_gpu_device>(),
        8usize,
        concat!("Alignment of ", stringify!(llmodel_gpu_device))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_gpu_device),
        "::",
        stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_gpu_device),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heapSize) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_gpu_device),
        "::",
        stringify!(heapSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_gpu_device),
        "::",
        stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(llmodel_gpu_device),
        "::",
        stringify!(vendor)
        )
    );
}
#[doc = " Callback type for prompt processing.\n @param token_id The token id of the prompt.\n @return a bool indicating whether the model should keep processing."]
pub type llmodel_prompt_callback =
::std::option::Option<unsafe extern "C" fn(token_id: i32) -> bool>;
#[doc = " Callback type for response.\n @param token_id The token id of the response.\n @param response The response string. NOTE: a token_id of -1 indicates the string is an error string.\n @return a bool indicating whether the model should keep generating."]
pub type llmodel_response_callback = ::std::option::Option<
    unsafe extern "C" fn(token_id: i32, response: *const ::std::os::raw::c_char) -> bool,
>;
#[doc = " Callback type for recalculation of context.\n @param whether the model is recalculating the context.\n @return a bool indicating whether the model should keep generating."]
pub type llmodel_recalculate_callback =
::std::option::Option<unsafe extern "C" fn(is_recalculating: bool) -> bool>;
#[doc = " Embedding cancellation callback for use with llmodel_embed.\n @param batch_sizes The number of tokens in each batch that will be embedded.\n @param n_batch The number of batches that will be embedded.\n @param backend The backend that will be used for embedding. One of \"cpu\", \"kompute\", or \"metal\".\n @return True to cancel llmodel_embed, false to continue."]
pub type llmodel_emb_cancel_callback = ::std::option::Option<
    unsafe extern "C" fn(
        batch_sizes: *mut ::std::os::raw::c_uint,
        n_batch: ::std::os::raw::c_uint,
        backend: *const ::std::os::raw::c_char,
    ) -> bool,
>;
extern "C" {
    #[doc = " Create a llmodel instance.\n Recognises correct model type from file at model_path\n @param model_path A string representing the path to the model file.\n @return A pointer to the llmodel_model instance; NULL on error."]
    pub fn llmodel_model_create(model_path: *const ::std::os::raw::c_char) -> llmodel_model;
}
extern "C" {
    #[doc = " Create a llmodel instance.\n Recognises correct model type from file at model_path\n @param model_path A string representing the path to the model file; will only be used to detect model type.\n @param build_variant A string representing the implementation to use (auto, default, avxonly, ...),\n @param error A pointer to a string; will only be set on error.\n @return A pointer to the llmodel_model instance; NULL on error."]
    pub fn llmodel_model_create2(
        model_path: *const ::std::os::raw::c_char,
        build_variant: *const ::std::os::raw::c_char,
        error: *mut *const ::std::os::raw::c_char,
    ) -> llmodel_model;
}
extern "C" {
    #[doc = " Destroy a llmodel instance.\n Recognises correct model type using type info\n @param model a pointer to a llmodel_model instance."]
    pub fn llmodel_model_destroy(model: llmodel_model);
}
extern "C" {
    #[doc = " Estimate RAM requirement for a model file\n @param model A pointer to the llmodel_model instance.\n @param model_path A string representing the path to the model file.\n @param n_ctx Maximum size of context window\n @param ngl Number of GPU layers to use (Vulkan)\n @return size greater than 0 if the model was parsed successfully, 0 if file could not be parsed."]
    pub fn llmodel_required_mem(
        model: llmodel_model,
        model_path: *const ::std::os::raw::c_char,
        n_ctx: ::std::os::raw::c_int,
        ngl: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " Load a model from a file.\n @param model A pointer to the llmodel_model instance.\n @param model_path A string representing the path to the model file.\n @param n_ctx Maximum size of context window\n @param ngl Number of GPU layers to use (Vulkan)\n @return true if the model was loaded successfully, false otherwise."]
    pub fn llmodel_loadModel(
        model: llmodel_model,
        model_path: *const ::std::os::raw::c_char,
        n_ctx: ::std::os::raw::c_int,
        ngl: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if a model is loaded.\n @param model A pointer to the llmodel_model instance.\n @return true if the model is loaded, false otherwise."]
    pub fn llmodel_isModelLoaded(model: llmodel_model) -> bool;
}
extern "C" {
    #[doc = " Get the size of the internal state of the model.\n NOTE: This state data is specific to the type of model you have created.\n @param model A pointer to the llmodel_model instance.\n @return the size in bytes of the internal state of the model"]
    pub fn llmodel_get_state_size(model: llmodel_model) -> u64;
}
extern "C" {
    #[doc = " Saves the internal state of the model to the specified destination address.\n NOTE: This state data is specific to the type of model you have created.\n @param model A pointer to the llmodel_model instance.\n @param dest A pointer to the destination.\n @return the number of bytes copied"]
    pub fn llmodel_save_state_data(model: llmodel_model, dest: *mut u8) -> u64;
}
extern "C" {
    #[doc = " Restores the internal state of the model using data from the specified address.\n NOTE: This state data is specific to the type of model you have created.\n @param model A pointer to the llmodel_model instance.\n @param src A pointer to the src.\n @return the number of bytes read"]
    pub fn llmodel_restore_state_data(model: llmodel_model, src: *const u8) -> u64;
}
extern "C" {
    #[doc = " Generate a response using the model.\n @param model A pointer to the llmodel_model instance.\n @param prompt A string representing the input prompt.\n @param prompt_template A string representing the input prompt template.\n @param prompt_callback A callback function for handling the processing of prompt.\n @param response_callback A callback function for handling the generated response.\n @param recalculate_callback A callback function for handling recalculation requests.\n @param special True if special tokens in the prompt should be processed, false otherwise.\n @param fake_reply A string to insert into context as the model's reply, or NULL to generate one.\n @param ctx A pointer to the llmodel_prompt_context structure."]
    pub fn llmodel_prompt(
        model: llmodel_model,
        prompt: *const ::std::os::raw::c_char,
        prompt_template: *const ::std::os::raw::c_char,
        prompt_callback: llmodel_prompt_callback,
        response_callback: llmodel_response_callback,
        recalculate_callback: llmodel_recalculate_callback,
        ctx: *mut llmodel_prompt_context,
        special: bool,
        fake_reply: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Generate an embedding using the model.\n NOTE: If given NULL pointers for the model or text, or an empty text, a NULL pointer will be\n returned. Bindings should signal an error when NULL is the return value.\n @param model A pointer to the llmodel_model instance.\n @param texts A pointer to a NULL-terminated array of strings representing the texts to generate an\n embedding for.\n @param embedding_size A pointer to a size_t type that will be set by the call indicating the length\n of the returned floating point array.\n @param prefix The model-specific prefix representing the embedding task, without the trailing colon. NULL for no\n prefix.\n @param dimensionality The embedding dimension, for use with Matryoshka-capable models. Set to -1 to for full-size.\n @param token_count Return location for the number of prompt tokens processed, or NULL.\n @param do_mean True to average multiple embeddings if the text is longer than the model can accept, False to\n truncate.\n @param atlas Try to be fully compatible with the Atlas API. Currently, this means texts longer than 8192 tokens with\n long_text_mode=\"mean\" will raise an error. Disabled by default.\n @param cancel_cb Cancellation callback, or NULL. See the documentation of llmodel_emb_cancel_callback.\n @param error Return location for a malloc()ed string that will be set on error, or NULL.\n @return A pointer to an array of floating point values passed to the calling method which then will\n be responsible for lifetime of this memory. NULL if an error occurred."]
    pub fn llmodel_embed(
        model: llmodel_model,
        texts: *mut *const ::std::os::raw::c_char,
        embedding_size: *mut usize,
        prefix: *const ::std::os::raw::c_char,
        dimensionality: ::std::os::raw::c_int,
        token_count: *mut usize,
        do_mean: bool,
        atlas: bool,
        cancel_cb: llmodel_emb_cancel_callback,
        error: *mut *const ::std::os::raw::c_char,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " Frees the memory allocated by the llmodel_embedding function.\n @param ptr A pointer to the embedding as returned from llmodel_embedding."]
    pub fn llmodel_free_embedding(ptr: *mut f32);
}
extern "C" {
    #[doc = " Set the number of threads to be used by the model.\n @param model A pointer to the llmodel_model instance.\n @param n_threads The number of threads to be used."]
    pub fn llmodel_setThreadCount(model: llmodel_model, n_threads: i32);
}
extern "C" {
    #[doc = " Get the number of threads currently being used by the model.\n @param model A pointer to the llmodel_model instance.\n @return The number of threads currently being used."]
    pub fn llmodel_threadCount(model: llmodel_model) -> i32;
}
extern "C" {
    #[doc = " Set llmodel implementation search path.\n Default is \".\"\n @param path The path to the llmodel implementation shared objects. This can be a single path or\n a list of paths separated by ';' delimiter."]
    pub fn llmodel_set_implementation_search_path(path: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get llmodel implementation search path.\n @return The current search path; lifetime ends on next set llmodel_set_implementation_search_path() call."]
    pub fn llmodel_get_implementation_search_path() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a list of available GPU devices given the memory required.\n @param memoryRequired The minimum amount of VRAM, in bytes\n @return A pointer to an array of llmodel_gpu_device's whose number is given by num_devices."]
    pub fn llmodel_available_gpu_devices(
        memoryRequired: usize,
        num_devices: *mut ::std::os::raw::c_int,
    ) -> *mut llmodel_gpu_device;
}
extern "C" {
    #[doc = " Initializes a GPU device based on a specified string criterion.\n\n This function initializes a GPU device based on a string identifier provided. The function\n allows initialization based on general device type (\"gpu\"), vendor name (\"amd\", \"nvidia\", \"intel\"),\n or any specific device name.\n\n @param memoryRequired The amount of memory (in bytes) required by the application or task\n                       that will utilize the GPU device.\n @param device A string specifying the desired criterion for GPU device selection. It can be:\n               - \"gpu\": To initialize the best available GPU.\n               - \"amd\", \"nvidia\", or \"intel\": To initialize the best available GPU from that vendor.\n               - A specific GPU device name: To initialize a GPU with that exact name.\n\n @return True if the GPU device is successfully initialized based on the provided string\n         criterion. Returns false if the desired GPU device could not be initialized."]
    pub fn llmodel_gpu_init_gpu_device_by_string(
        model: llmodel_model,
        memoryRequired: usize,
        device: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a GPU device by specifying a valid gpu device pointer.\n @param device A gpu device pointer.\n @return True if the GPU device is successfully initialized, false otherwise."]
    pub fn llmodel_gpu_init_gpu_device_by_struct(
        model: llmodel_model,
        device: *const llmodel_gpu_device,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes a GPU device by its index.\n @param device An integer representing the index of the GPU device to be initialized.\n @return True if the GPU device is successfully initialized, false otherwise."]
    pub fn llmodel_gpu_init_gpu_device_by_int(
        model: llmodel_model,
        device: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @return True if a GPU device is successfully initialized, false otherwise."]
    pub fn llmodel_has_gpu_device(model: llmodel_model) -> bool;
}
extern "C" {
    #[doc = " @return The name of the llama.cpp backend currently in use. One of \"cpu\", \"kompute\", or \"metal\"."]
    pub fn llmodel_model_backend_name(model: llmodel_model) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return The name of the GPU device currently in use, or NULL for backends other than Kompute."]
    pub fn llmodel_model_gpu_device_name(model: llmodel_model) -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
